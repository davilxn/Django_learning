Seção 5 - Django Urls, Views e templates
Agora, iremos entender mais profundamente os arquivos e estruturas do django.

# O que iremos criar nesse projeto: 
    # Criar um site de receitas: Cadastro de receitas com todas as informações (muitas informações, justamente pra contribuir com o aprendizado).
      Os clientes poderão escrever suas receitas no site, mas elas não serão publicadas, e sim avaliadas por um administrador, para avaliá-las e 
      só então decidir se publica a receita ou não. É um site simples, mas que passa por praticamente tudo que o django é capaz de fazer, então
      irá, embora simples, ser bem completo, didaticamente.

# Urls.py
    # Sempre que acessamos um site e suas diversas páginas e ramificações, acessamos através de URLS.
    # Toda URL possui seu domínio, suas terminações e, ao fim, uma /. 
        # Ex: www.Otaviomiranda.com.br, mas quando acessamos o domínio, vê-se: www.Otaviomiranda.com.br/.
        # Isso significa que estamos na raíz do site, na página principal ou na porta de entrada do site.
    # O que vem após a /, diz respeito a outras páginas do site que também podem ser acessadas pelo usuário.
        # Ex: www.Otaviomiranda.com.br/sobre    ou   www.Otaviomiranda.com.br/cursos
    
# Criando Rotas/Paths no django
    # No arquivo Urls.py, utilizamos a função path para criar rotas/caminhos/paths e atribuí-los à páginas (do site). A função path recebe, 
      no mínimo, dois argumentos: uma rota (do tipo string, de modelo: 'rota/'. A / no fim é obrigatória) e uma view. 
        # As views são funções presentes dentro de cada arquivo 'views' de cada aplicação (app). 
        # As views recebem como argumentos *args e *kwargs, que serão a request realizada.
        # De maneira simples: Quando digitamos uma url no navegador, estamos fazendo com que o navegador realize uma request utilizando o 
          protocolo http para aquela url, para aquele endereço, isto é, para aquele específico 'path' (o path que contém o endereço que o 
          usuário quis acessar), e então o servidor vai receber essa request e vai passar ela como argumento para a view, através da função 
          path(). Isso é chamado de HTTP REQUEST.
          Após esse processo, a view deve retornar uma HTTP RESPONSE, isto é, um objeto HttpResponse. O servidor irá retornar essa HttpResponse
          para o cliente, que fez a HttpRequest (que requisitou algo do servidor). 
        # Como, até este ponto, ainda não vimos 'apps', criaremos uma view temporária dentro do arquivo Urls.py. 
          Ex. path('sobre/', viewinventada). Nesse momento, agora o site possui uma url http://127.0.0.1:8000/sobre, que irá carregar
          a view 'viewinventada'. Como dito, a path passará para a viewinventada um argumento, que é uma request, mas a viewinventada não 
          tem parâmetros, então gera erro. Criado o parâmetro 'request' para viewinventada, agora ela receberá a request, mas ainda não está
          devolvendo uma HTTPRESPONSE. Para fins puramente didáticos fez-se from django.http import HttpResponse e:
          
          def viewinventada(request):
            return HttpResponse("Hoje é um bom dia para aprender django.")
          
          Posteriormente, veremos que estas HttpResponse's serão arquvos HTML que serão carregados e mostrarão a página requisitada pelo cliente.
          O cliente pediu (requisitou, fez a request) e o nosso site retornou a resposta.

# Visão geral sobre o protocolo HTTP e o http request e o http response
  # O protocolo HTTP é um protocolo utilizado geralmente para navegar na internet ou trafegar coisas na internet. Ele funciona nos modos de 
    REQUEST e RESPONSE: o CLIENTE faz uma REQUEST para o site e o servidor que representa o site deve recebê-la e retornar uma RESPONSE com o 
    que foi solicitado pelo cliente.

    O HTTP é um protocolo de comunicação, ou seja, uma convenção de regras e padrões que controla e possibilita uma conexão e troca de dados 
    entre dois sistemas computacionais.
    É baseado no modelo de cliente-servidor, ou seja, de um lado, um navegador requisita um determinado dado, e do outro, um computador 
    (ou servidor) retorna a informação desejada (ou não, caso não ela seja encontrada, ocorra um erro ou não exista).

    Clientes e servidores se comunicam pela internet trocando mensagens individuais. As mensagens enviadas pelo cliente, geralmente navegadores 
    web, são chamadas de requisições (requests). As réplicas dos servidores são chamadas de respostas (responses), podendo conter algum 
    conteúdo (como arquivos HTML) além de informações sobre o status da requisição.

  # Entendimento sobre MÉTODOS DE REQUISIÇÃO HTTP:
    O protocolo HTTP define oito métodos de requisição (GET, POST, PUT, DELETE, HEAD, TRACE, OPTIONS e CONNECT) para indicar qual ação deve ser 
    realizada no recurso especificado. Os métodos GET e POST, PUT e DELETE são os mais utilizados em aplicações web. Um servidor HTTP deve 
    implementar, pelo menos, os métodos GET e HEAD para ser funcional.
    No django, os mais usados são o GET e o POST. Ao usar django rest, passaremos a ver o método TRACE com frequência, também.
    Mais info sobre os méotodos: https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Methods

    GET - Solicitação de dados
    POST - Solicitação para editar

    # Breve entendimento sobre Código de Status de Resposta HTTP (RESPONSE)
      # Respostas de informação (100 - 199)
      # Respostas de sucesso (200 - 299)
      # Redirecionamentos (300 - 399)
      # Erros do cliente (400 - 499) - Error 404 (page not found), lembra?
      # Erros do servidor (500 - 599)

  # Numa das páginas que você criou, clique com o botão direito e clique em "inspecionar". Depois em "Network" e Ctrl +  R.
    # Você vai ver informações importantes sobre as responses retornadas pelo servidor (status, tipo, tamanho, tempo)
    # Também verá todos os arquivos que foram trazidos quando a página em questão foi carregada. Ao clicar em um desses, você verá informações
      importantes:
        # Aba GENERAL: 
          - A URL para a qual a requisição foi feita;
          - Status code;
          - O endereço remoto;
          - Política de referência
        # Request headers: 
          - Meta dados mandados para o servidor quando a request é realizada. Esses metadados são enviados pelo mecanismo que tipo
            ver realizado a request, nesse caso, o navegador, e informa que tipo de dados o mecanismo (o navegador) pode aceitar como resposta do 
            servidor (os tipos de arquivo e etc.)
          - Ecoding;
          - Idiomas aceitos;
          - Host
        # Response headers: 
          - Tamanho do conteúdo;
          - Tipo do conteúdo;
          - Data;
          - Servidor
          - Segurança

# Aplicações (app's) no django
  # Em um projeto django, podemos ter várias aplicações, cada uma com sua tarefa e função específica, e estas aplicações, depois de criadas, 
    podem ser utilizadas em outros projetos. Um projeto é formado pelo conjunto de suas aplicações e funcionamento em conjunto de todas elas.
    Exemplo: Projeto -> E-commerce ; Apps -> Clientes, pagamentos, carrinhos, pedidos, entregas, produtos, promoções, etc.
    
    É muito importante que sua app tenha uma responsabilidade única e bem definida. Isso viabiliza o reaproveitamento e simplifica a manutenção
    do seu código, pois estamos falando de áreas do projeto que devem interagir entre si.

  # Criar as aplicações do projeto: manage.py startapp nomedaapp. Para que o django reconheça suas aplicações (app's) é necessário adicionar 
    os nomes das aplicações criadas à lista 'INSTALLED_APPS', no arquivo 'settings',no diretório do projeto. O nome a ser adicionado é 
    literalmente o nome da app criada, que pode ser encontrado no arquivo apps.py da app em questão, no atributo 'name' da classe AppConfig.

  # Nesse caso (início do aprendizado), haverá somente um app.
  # O app criado será chamado de 'receitas'.
  # DENTRO DO VENV: python manage.py startapp recipes

# Refazendo paths e views, com apps
  # Tudo o que foi criado dentro do Urls.py de projeto1 (as views e paths) irão para dentro da app 'recipes'. No entanto, ainda precisaremos 
    dos paths que foram criados, dentro do arquivo Urls.py de projeto1.
  # Crie um arquivo Urls.py dentro de recipes e cole todos os paths referentes à app 'recipes' (nesse caso, a unica app, então são todas os 
    paths). Após isso, dentro de urls.py de projeto1, faça: from django.urls import include, path; depois, troque todos os paths por:

                                                    path('', include('recipes.urls'))

  # Como iremos mover as views para outro arquivo (views.py de recipes), devemos importá-las para que possamos continuar utilizando-as no 
    arquivo Urls.py para configuar as paths.

  # Isso resulta em: a view.py e urls.py das aplicações serão arquivos horríveis, no entanto, a view.py e urls.py do projeto será limpa, pois lá
    é o coração.

  # As páginas que aparecem no seu site são arquivos HTML carregados sempre que uma view é executada. Até esse momento, nossas views
    só retornam uma HttpResponse genérica, e passarão a retornar arquivos html bem estruturados e bonitos, para construir páginas agradáveis.

  # No entanto, construir uma página com HTML dentro de cada view seria caótico. Para isso, utilizaremos a função 'render()':
    # from django.shortcuts import render

    # A função render recebe 3 parâmetros principais: A request em questão, o caminho de um arquivo HTML (arquivo esse que será a página) e um 
      context.

    # Ao invés de retornar HttpResponse('Olá mundo), será: return render(request, 'home.html').

    # Todos os arquivos html referentes às páginas do site ou da aparência da aplicação devem ser armazenados em um diretório chamado 
      'templates', dentro de cada aplicação. Deve se chamar 'templates', pois o Django é inteligente o suficiente pra buscar os arquivos cujos
      caminhos foram informados na render, dentro desta pasta.

    # Pra evitar que uma busca do django por arquivos html de mesmo nome termine em erros, convenciona-se criar, dentro da pasta de templates 
      da app, uma outra pasta com o nome da app e pôr todos os arquivos html dentro dessa pasta. A consequência disso vem no momento de passar
      o caminho do arquivo html para a função render: ao invés de ser "render(request, 'home.html')", será "render(request, 'app/home.html')", E
      no nosso caso específico: "render(request, 'recipes/home.html')".

# Partial e pages
    # Podemos dividir um arquivo de template (uma página do site) em vários arquivos parciais. Isso promove organização e permite que várias 
      pessoas trabalhem no mesmo projeto sem colisões.
    # Para finalidades práticas e organizacionais, cria-se, dentro de templates/recipes, duas pastas: 'partials' e 'pages'. Partials conterá 
      partes de uma página que podem aparecer em outras páginas do site (por isso, parcial, de parte), enquanto 'pages' conterá os arquivos 
      html prontos das páginas. 'home.html', por exemplo, estará localizada na pasta pages.
    # Uma 'parte' ou 'parcial' importante a se ter em 'partials' é o footer.html, que será o rodapé de todas as páginas do site.
    # Quando dividimos as páginas em partes, dessa forma, devemos conseguir juntá-las. Quando a parte que compõe o head.html foi cortada de
      home.html para que pudesse compor a partial (head.html), o arquivo home.html virou um arquivo html incompleto, sem head, sem stylesheets,
      sem títulos, sem links e etc. Isso porque essas tags, agora, estão separadas no arquivo head.html. Como juntar integrar a partial 
      head.html à página home.html e a todas as outras páginas? Entende-se que devemos incluir head.html em home.html e, para isso, 
      utilizaremos a tag do django chamada 'include'. Antes do início das tags de home.html, digite include, no topo da página:

                                    {% include 'recipes/partials/head.html' %
    de modo generalizado, utiliza-se a tag 'include' do django da seguinte forma:
                                    {% include 'pathdoarquivohtmlquesedesejaincluiraoarquivoemquestão' %}

# Mostrando coisas no template através da view (Mostrando coisas do backend no frontend) 
  # O 3° parâmetro da funçãor render é o context, e através dele, podemos criar variáveis e utilizá-las dentro dos seus templates:
  # Isso pode ser feito passando um dicionário como argumento para o parâmetro context da render, ex: 
                                  render(request, 'recipes/home.html', context={'nome':'Davi'})
  # Ou adicionando um dicionário dentro da view, fora da render. Nesse caso, para aparecer na página, deverá passar o dicionário como argumento do parAmetro context da render, 
    também. Ex:
                      def viewinventada(request):
                        texto = {'nome':'davi'}
                        return render(request, 'recipes/home.html', context = texto)
  # Em ambos os casos, para exibir algo dentro de um template através das views pelo django, faz-se, dentro do template: '{{ chave }}'
    dentro da tag body. Sempre que houver {{}}, num template, é porque estamos tentando mostrar algo através do django.

# OBS IMPORTANTE: Todos os templates presentes nesse projetos estão sendo copiados do material do curso, devido à completa incapacidade do progra
mador que vos fala no que diz respeito à habilidades de frontend.
