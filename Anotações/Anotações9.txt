'Seção 13 - Django forms - Criando formulários soltos ou formulários baseados em Models

# Nesta seção trabalharemos com os autores, resgistrando-os, criando uma tabela (Model), autenticando, entregando permissões e configurando
  suas interações com o site.
# De início, faremos uma APP 'authors', para que possamos trabalhar com autores de maneira adequada.
    # Faça toda a configuração necessária para esta APP.
    # Criação da view register_view.
    # Criação do template register_view.html. Extensão do global/base.html.
# Para cadastrarmos o usuário, precisaremos criar um formulário, e aí iniciamos o trabalho com os Django Forms.
  # Crie dentro da app authors, sem pasta específica, um arquivo forms.py.
  # Existe duas maneiras de criar um fomulário no django:
    - Criar um formulário seco, sem dados atrelados a ele: from django.forms import forms
    - Criar um formulário atrelado a um Model: from django.forms import ModelForm
    - Como podemos utilizar as duas maneiras, faremos: from django import forms
  # Queremos criar um formulário atrelado a um Model. No entanto, lá na app recipes, não criamos um model para usuários, mas utilizamos um model
    pronto do django para usuários e, com ele, permitiremos que os usuários criem suas contas: from django.contrib.auth.models import User.
  # Criamos em fomrs.py uma classe RegisterForm, que herda de models.ModelForm e, dentro dessa classe, obrigatoriamente, escreveremos a classe
    Meta, que utlizaremos para passar metadados para o django. Dentro dela, escreveremos muita coisa específica, mas até esse ponto, tem-se:

      class RegisterForm(forms.ModelForm):
        class Meta:
          model = User           # A qual model o formulário estará atrelado: User, afinal, queremos cadastrar usuários. Poderia ser a nossa classe Usuários, mas ela nem existe :)
          fields = '__all__'      # Quais campos desse model o django vai pôr no formulário: todos (username, first_name, last_name e todos os atributos do model User)
  
    # Dentro da view register_view, criemos um formulário baseado nesse model e passá-lo no contexto. Faça:

          form = RegisterForm()

    # Mas é óbvio que não permitiremos que o usuário possa escolher suas próprias permissões ou dizer se ele é, por exemplo, um superusuário
      ou não. Modifiquemos isto no Model RegisterForm, na classe Meta, mudando o atributo fields:

      class RegisterForm(forms.ModelForm):
          class Meta:
            model = User           
            fields = [
              'username',
              'first_name',
              'last_name',
              'email',
              'password',
            ]
  ### Trabalhando com labels, widgets, erros e atributos dos campos
    # Ao invés de utilizar o atributo fields, pra selecionar os campos um por um, pode-se utilizar o 'exclude', que vai selecionar todos os 
      campos, menos os que você selecionou.
    # Labels: Mensagem visível que vai aparecer do lado de fora das caixinhas dos campos. Faz-se, dentro da class Meta, 
      dentro do Model responsável pelo formulário (RegisterForm):

                    labels = {
                      'username': 'Digite seu nome de usuário',
                      'firts_name': 'Digite seu nome',
                      'last_name': 'Digite seu sobrenome',
                      'email': 'Digite seu email',
                      'password': 'Digite sua senha'
                    }
    # help_texts: Texto de ajuda de cada campo que vai aparecer para o usuário. Ex: 'Este campo deve ser preenchido somente com números inteiros.'
      Faz-se:

                    help_texts = {
                      'email': 'Este email deve ser um email válido.'
                    }
    # error_messages: As mensagens de erro que aparecerão, caso, ocorra algo inadequado, pelo preenchimento do formulário. Os erros tem códigos,
      que virão na forma de dicionário, indicando que mensagem vai aparecer, de acordo com o tipo de erro:

                    error_messages = {
                      'username': {
                        'required': 'Esse campo não pode estar vazio',
                        'max_length': 'Este campo não pode ultrapassar os 50 caracteres.'
                        'invalid': 'Usado para passar mensagens mais genéricas'
                      }
                    }
    # widgets: Widgets geralmente são utilizados para pôr placeholders em campos (mensagens dentro dos campos que aparecem enquanto nada é 
    digitado):

                widgets = {
                  'first_name': forms.TextInput(attrs={
                    'placeholder': 'Digite seu nome aqui'
                  }),
                  'password': forms.PasswordInput(attrs={
                    'placeholder': 'Digite sua senha aqui'
                  })
                }
  ### Sobrescrevendo campos do formulário completamente
    # Dentro da classe de formulário RegisterForm() crie um novo campo (fora da classe Meta, portanto, não atrelado ao model de usuário):

              password2 = forms.CharField(
                required = True,
                widget = forms.PasswordInput(attrs={
                  'placeholder': 'Repita sua senha'
                })
              )
              
    
    # Para sobrescrever um campo que está dentro da classe Meta, basta recriálo, com o mesmo nome, fora da classe Meta. Sobrescrevendo o campo
      password, por exemplo:

          password = forms.CharField(
                required = True,
                widget = forms.PasswordInput(attrs={
                  'placeholder': 'Repita sua senha'
                }),
                error_messages={
                  'required': 'Este campo deve ser preenchido'
                },
                help_text = ''Informe seu email acima'
              )
 
  ### Modificando o template register_view.html
    # Até esse exato ponto, os campos selecionados estão funcionando e aparecendo para serem preenchidos como formulário. No entanto, esses
      campos são mostrados de uma maneira nada estética.
    # Novamente, trata-se de algo cujo estilo, de maneira geral, não varia tanto, e não faz muita diferença se variar, portanto, pode ser 
      copiado.
            <div class="main-content center container">
              <h2>Register</h2>
            </div>

            <div class="main-content container">
              <form action="" method="POST">
                {% csrf_token %}

                <div class="form-content form-content-grid">
                  {% for field in form %}
                    <div class="form-group">
                      <label for="{{ field.id_for_label }}">{{ field.label }}</label>
                      {{field}}

                      {% if field.help_text %}
                        <p class="help-text">{{ field.help_text }}</p>
                      {% endif %}

                      {{ field.errors }}
                    </div>
                  {% endfor %}
                </div>

                <div class="form-group">
                  <button type="submit">Send</button>
                </div>
              </form>
            </div>


    # Perceba que utilizamos aqui o método POST. Isto porque agora estaremos buscando informações através do corpo da request e não da URL como
      fazíamos com o GET.
    # Também estamos utilizando a tag django CSRF (Cross-Site Request Forgery). CSRF é um tipo de ataque vindo de sites maliciosos. Um ataque 
      CSRF envia solicitações não autorizadas de um usuário no qual o website confia. É, basicamente um site mandar um POST (request cujo método
      é o POST) para o seu site, o seu site aceitar (porque, foi feito enquanto um usuário de confiança do site estava utilizando).
      Por exemplo: Um usuário de confiança está logado no site, e outro site envia um post fazendo uma requisição para que a conta daquele 
      usuário tenha seus dados modificados. O seu site vai aceitar essa requisição e vai realizar. 
    # Isto significa que, para todo formulário de método POST no nosso site, deveremos utilizar a tag {% csrf_token %} do django. Através dela, 
      estamos comunicando ao django que o formulário em questão, com o POST em questão, está sendo enviado pelo usuário (e está mesmo, pois é
      um fomulário que nós criamos e nós passamos para o usuário responder quando ELE fez a requisição do formulário para que ELE mesmo
      pudesse fazer seu cadastro). Dentro das tags html form, nos templates, antes de mais nada, utilize: {% csrf_token %}
    # Para receber os valores preenchidos do formulário, devemos fazer o mesmo esquema de quando precisávamos receber dados específicos da 
      URL com QueryStrings, mas dessa vez, por procurarmos dados do corpo da requisição, utilizamos o request.POST e não o request.GET.
      # Dentro da view register_view, faça:

        if request.POST:
          form = RegisterForm(request.POST)     
        else:
          form = RegisterForm()
      
      # Isto é, se o fomulário tiver sido preenchido, a variável form receberá os dados do fomulário e faremos algo com eles. Do contrário, 
        recebe um fomulário vazio para ser preenchido.
      # No entanto, na view estamos recebendo os dados do formulário, mas no template não estamos fazendo nada, pois quando enviamos o formulário
        preenchido, a página simplesmente recarrega o formulário (os dados foram recebidos, mas a página só recarregou o fomulário). 
        Para resolver esse problema, iremos criar uma nova view e mudar o template do formulário para, assim que enviarmos o formulário, carregar
        mos outra view e outro template. Criemos a view register_create. 
          # Isso vai mudar inclusive a estrutura da register_view, pois a register_view vai carregar somente o formulário vazio, enquanto a 
            view register_create vai receber os dados do formulário preenchido e carregar outra coisa. Essa nova view não será responsável
            por carregar um novo template, e sim por receber, ler e validar os dados recebidos com o preenchimento do formulário e, a partir da
            validação, registrar o novo usuário ou retorna uma mensagem dizendo que houve algum erro com os dados do formulário.
          # Dentro dessa nova view, haverá um IF para verificar se existe uma request.POST:

                        if not request.POST:
                          raise Http404()

          # A única maneira de acessar a página cuja url é register/create é preenchendo um formulário e o enviando, pois só quando enviamos o
          formulário, estamos requerindo um POST. Quando digitamos a url no navegador diretamente, estamos requisitando um GET, por padrão
          e isso resultará no IF acima.
        # Uma coisa que deverá entrar em funcionamento é: a register_view é chamada e carrega o formulário vazio a ser preenchido. O usuário
          preenche e envia, chamando a register_create, que fará a validação. Se a validação detectar algum erro, a register_view deve ser
          chamada novamente, mostrando um novo fomulário a ser preenchido, cujos campos que foram preenchidos erroneamente foram apagados e os 
          que foram preenchidos corretamente, mantidos, além de mostrando uma mensagem de erro informando o que aconteceu. Mas para isso, preci
          saríamos passar os dados recebidos pela register_create para a register_view, e isso é, com os atuais conhecimentos, impossível.
            # Para consertar esse problema, utilizaremos um mecanismo chamado SESSION. 
              Uma SESSION está atrelada ao ID do navegador do usuário, isto é, quando o usuário acessa o sistema, o sistema registra o ID da
              sessão do usuário, mais especificamente, o ID do navegador do usuário. Então cada usuário que acessar o site, ou cada navegador 
              que acessar o seu site, terá um cookie com esse ID de sessão registrado. A sessão só muda quando entramos no site por uma aba
              anônima, ou com um navegador diferente ou com outro usuário. Esse mecanismo é o que vai ser utilizado para sabermos se um usuário
              está logado ou não. A partir disso, podemos coletar informações referentes a essa sessão do usuário e salvar no nosso servidor. 
              # Se eu quiser, por exemplo, acessar o número de vezes que uma pessoa acessou a register_view dentro daquela sessão, eu crio uma
                variável dentro da sessão, acessando a sessão diretamente (e essa variável será um dicionário):

                            request.session['access_number'] = algumacoisa
              
              # Semore que essa view for carregada, deverá ter seu valor incrementado em 1 (afinal, foi mais um acesso àquela página). Mas para
                isso, devemos criar a variável de forma a realizar a seguinte verificação: 

                            request.session['number'] = request.session.get('number') or 0
                            request.session['number'] += 1

                    Isto é, a variável request.session irá receber o valor 0 (se essa variável ainda não tiver nenhum valor, isto é, se é a
                    primeira vez do usuário acessando o site) ou então irá receber o valor que ela já possui (se esta não tiver sido a primeira 
                    vez que o usuário acessa o site).
                    Para mostrar no template, é só passar na context.
              # No entanto, isso foi só pra exemplificar. Agora, utilizaremos para resolver o problema proposto anteriormente.
            # Para resolver o problema, devemos ser capazes de trafegar dados entre a register_create e a register view, e para isso, utilizare
              mos a SESSION.
                # Assim que recebermos os dados do formulário preenchido na register_create, iremos salvá-lo na sessão. Para isso, modifica-se
                  a register create da seguinte forma: (a mudança estará registrada no github).

                        POST = request.POST
                        request.session['register_form_data'] = POST
                        form = RegisterForm(POST)

                # Nesse caso, a view register_create não vai carregar um template, nem renderizar nada. Vai somente ler os dados do POST, 
                validar, e retornar para a register_view. Dessa forma, devemos ser redirecionados para ela:

                        return redirect('authors-register')

                # Dessa maneira, como salvamos os dados do formulário na sessão, poderemos acessá-los a partir da register_view. Assim, faça
                  mos na register_view, para que ela receba esses dados:

                    register_form_data = request.session.get('register_form_data', None) # Isto é, ou recebe o valor da chave passada (que está dentro da sessão) ou o valor None.
                    form = RegisterForm(register_form_data)

                # Isso porque a register_view pode receber dois valores que representam os dados do formulário: ou o register_form_data (o valor recebido da
                  register_create, depois que o usuário preencheu e a register_create validou os dados) ou None (Se o usuário tiver solicitado um formulário
                  de cadastro para preencher pela primeira vez).
                  # Até esse momento, o que está acontecendo é o seguinte: O usuário solicita o formulário pela primeira vez, o preenche e o
                    envia. Quando envia, a register_create recebe, lê, valida e salva os dados preenchidos na sessão e redireciona o site
                    para a register_view, chamando-a e passando os valores que foram preenchidos. Então o usuário está respondendo o formulário
                    e quando ele o envia, a página é recarregada e reaparece com os mesmos dados que ele digitou lá. Isso acontece porque a 
                    register_create ainda não está terminada pois, até este ponto, ela ainda não faz validação.
                    Posteriormente, após realizar a validação, faremos com que, caso não tenha ocorrido erro e o usuário tenha podido se cadastrar,
                    seja direcionado para outra página ou apareça uma mensagem de sucesso ou apareça o fomulário de novo, mas limpo, sem dados. caso
                    ocorra algum erro, aparecerá o formulário com indicações de onde houve erro. Mudança importante, registrada no github.
    
  ### Validando campos do formulário
    # Utilizando clean_field para validar um campo específico
      # Para isso, dentro da classe de formulário (fora da Meta), devemos escrever uma função com o seguinte formato:

            def clean_nomedocampo(self):
              data = self.cleaned_data.get('nomedocampo')
              
              # Exemplo de validação

              if 'atenção' in data:
                raise ValidationError("Não digite a palavra atenção", code='invalid')

              return data

        # Onde:
          # Devemos importar a função ValidationError: from django.core.exceptions import ValidationError
          # 'invalid' é a mensagem genérica de erro que foi citada anteriormente.
          # Essa função é uma função específica do django, que funciona com base nos campos do formulário criado. Ao não passar pela validação
            dessa função, o formulário não é enviado.

      # Utilizando o método clean para validar um campo que depende de outro no formulário (os de senha)
        # O método clean é um método específico do django que, ao contrário do anterior, não se restringe a apenas um campo, mas tem acesso a todos,
          isto é, valida o formulário como um todo, logo, deve ser chamado somente depois dos clean_field. Deve ser feito no seguinte formato:

              def clean(self):
                cleaned_data = super().clean()
                password = cleaned_data.get('password')
                password2 = cleaned_data.get('password2')

                if password != password2:
                  raise ValidationError({
                    'password':'As senhas estão diferentes',
                    'password2': 'As senhas estão diferentes'
                    )
    
  # Salvando os dados do formulário na base de dados
    # Após validar os dados preenchidos do formulário, devemos salvar esses dados na base de dados, mandar uma mensagem para o usuário 
      informando que os dados foram salvos, isto é, que ele foi cadastrado com sucesso e, na hora de recarregar o formulário, devemos carregá-lo
      limpo, ou seja, limpar o register_form_data que foi salvo na sessão.
    # is_valid e save para salvar dados do formulário na base de dados
      # Para terminar de validar o formulário, dentro da register_create, faz-se:

          if form.is_valid():
            form.save()
            messages.success(request, 'Your user has been created, please log in.')
            del(request.session['register_form_data'])

        # Onde:
          # A função is_valid() verifica se o formulário recebido é válido de acordo com as funções clean e retorna True ou False
          # form.save() vai salvar os dados do formulário na base de dados.
          # messages.sucess vai mostrar a mensagem. from django.contrib import messages
          # del() vai limpar os dados presentes dentro de alguma chave.
  
  # Corrigindo erros de preenchimento - Problema na senha e no email
    # Senha: Quando o usuário é cadastrado, a senha fica com formato de senha inválido. Isso porque estamos salvando ela como string, o que 
      deve ser consertado.

      Lá na register_create, substitua o form.save() por:

          user = form.save(commit=False)
          user.set_password(user.password)
          user.save()

        # Onde:
          # commit=False faz com que os dados não sejam salvos na base de dados, mas na variável.
          # user.set_password(): Essa função recebe uma string (que, nesse caso, deve ser a senha do usuário) e vai criptografar essa string.
          # user.save() salva os dados (tendo, nesse caso, o valor de um dos campos criptografado, que é a senha)
    # Email: Estamos permitindo que usuários diferentes possuam o mesmo email. Para consertar, na classe do formulário, fora do Meta, faz-se
      uma validação simples:        (faça o mesmo com o nome de usuário)

        def clean_email(self):
        email = self.cleaned_data.get('email', '')
        exists = User.objects.filter(email=email).exists()

        if exists:
            raise ValidationError('Este e-mail já foi cadastrado.')

        return email
  
  # Para fins organizacionais, iremos mover arquivos de estilo e partials que pertecem ao app recipe e que estão sendo usados no app authors
    para pastas globais. Antes de fazer estas modificações, irei deixar o commit: reorganizando os arquivos da aplicação
      # styles.css do app recipes para o base_static (se não existir essa pasta, crie)
      # Fora receita.html, todas as partials da pasta templates do app recipe devem ir para base_templates

