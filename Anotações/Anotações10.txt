# Seção 15 - Criando a dashboard do autor (área administrativa, CRUD e etc)

# Nessa área, com o usuário estando logado, poderá criar receitas, apagar receitas, editar receitas. Poderíamos fazer com que ele pudesse 
  editar seu nome de usuário, seu nome, senha, email e etc. 
# De fato, temos o /admin, que é a área administrativa do django, no qual eu, desenvolvedor, posso fazer tudo o que foi dito acima, 
  mas é inviável que os clientes e usuários tenham acesso a ela.

### Criando a página inicial da dashboard
  # Crie um template: Copie o register_view.html e mude o nome para dashboard.html e faça modificações ao seu gosto.
  # Crie uma view dashboard. Lembre-se, um usuário só pode acessar sua dashboard se estiver logado no sistema, então, nessa view, utilizaremos
    o decorator login_required.
  # Crie a url.
  # Para fins organizacionais, recortou-se a parte de mensagens do template login.html e pôs-se no arquivo login_messages.html em
    authors/partials, e quando precisarmos daquela mensagem, utilizamos o include.

### Ajustando a área administrativa do django
  # Não podemos permitir que o usuário edite uma receita dele que já foi publicada.
  # Como já foi dito em seções anteriores, o funcionamento padrão do site é: O usuário cadastra uma receita, o admin do site recebe, avalia e,
    se achar válida, publica. No entanto, da maneira como a área administrativa do django está agora, esse mecanismo tende à desorganização.
    Nesse sentido, iremos atrás de formas de ordenar, buscar, filtrar e encontrar receitas dentro da área administrativa do django.
  # Lá na app recipes, no arquivo admin.py, visualize a classe RecipeAdmin. Dentro dela, faça:

        list_display = ['id', 'title', 'author', 'created_at', 'is_published']
    
    # Você perceberá que somente o id das receitas irá atuar como link. Se quiser fazer com que outros atributos também atuem, faça:

        list_display_links = ['title']
    
    # Podemos ainda, criar campos de busca de acordo com os atributos da receita. Faça:

        search_fields = ['id', 'title', 'description', 'preparation_steps'] 

    # Podemos também filtrar os dados, nesse caso, as receitas, na área administrativa. Para isso, faça: 

        list_filter = ['category', 'author', 'is_published', 'preparation_steps_is_html']

    # Podemos mudar a quantidade de itens que aparece por página dentro da área administrativa. Faça:

        list_per_page = 10
      
    # Podemos decidir o que poderá ser editado pelo admin quando a lista de objetos/receitas está sendo mostrada (Somente os campos mostrados 
      em list_display podem fazer parte daqui). Faz-se:

        list_editable = ['is_published']
    
    # Podemos ordenar a lista de receitas que aparece. Faça:

        ordering = ['-id']
    
    # Uma utilidade específica que ainda podemos realizar dentro dessa classe é fazer com que o slug de uma receita seja preenchido automatica
      mente quando a o título da receita for criado. Para isso, fazemos:

          prepopulated_fields = {
            'slug': ('title')
          }

### Exibindo as receitas que o usuário criou em sua prórpia dashboard
  # Tudo o que faremos é buscar a queryset de receitas de um usuário em específico (o que está logado). from recipes.models import Recipe, e
    faça:

      receitas = Recipe.objects.filter(is_published=False, author=request.user), e passa ela na context.

      # OBS. Só deve aparecer na dashboard do usuário as receitas dele que ele pode editar, isto é, as que ainda não foram publicadas.
  # Agora, precisamos mostrar essas receitas no template. Em dashboard.html, façamos:

    <div class='authors-dashboard-container'>
      <h3>Suas receitas</h3>
      <ul>
        {% if tam > 0 %}
          {% for receita in receitas %}
            <li>
              <a href='#'>{{ recipe.title }}</a>
            </li>
          {% endfor %}
        {% else %}
          <p>Você não possui receitas não publicadas.</p>
        {% endif %}
      </ul>
    </div>
  
  # Você pode ter imaginado que talvez seja necessário realizar uma paginação. De fato, mas isso fica para outra hora.
### Criando uma view, template e URL para o usuário editar as receitas dele
  # O template criado teve como base o dashboard.html. Fez-se as modificações necessárias no template para que apareça algo quando o usuário 
    clicar em uma receita no seu dashboard. Será o dashboard_recipe.html.
  # Cria-se a view, copiada da view dashboard, e será a dashboard_recipe_edit. Essa view receberá, além da request, um id, que será utilizado 
    para buscar uma receita específica com a queryset, tendo como parâmetro extra o PK que receberá como argumento esse id. Importante ressaltar
    que essa view, assim como tudo que envolve o dashboard só pode ser acessado se o usuário estiver logado, então essa view terá como decorador
    o login_required.
    Quando o usuário clicar na receita no dashboard (que é um link), chamará essa view, que renderizará o template mostrando o formulário
    para editar a receita na qual ele clicou.
  # Cria-se a url, com o adendo do ID.
  # Agora, devemos criar um formulário para que o usuário possa editar a receita.
    # Dentro de forms.py, crie o formulário AuthorRecipeForm, e vai herdar de forms.ModelForm. Isto significa que será um formulário que será
      herdado de um model, isto é, sua estrutura e seus campos vem de um model já criado, que será o model Recipe. Façamos:

        from django import forms
        from recipes.models import Recipe
        class AuthorRecipeForm(forms.ModelForm):
          class Meta:
            model = Recipe
            fields ['title', 'description', 'preparation__time', 'preparation__time_unit', 'servings', 'servings_unit', 'preparation_steps', 'cover']
    
    # Utilizaremos esse form dentro da view dashboard_recipe_edit.
      # Esse formulário dentro da view poderá ou não ser passado para o template (mostrado) com dados, para isso, usamos o request.POST.
        Faremos: 
            form = AuthorRecipeForm(request.POST or None, instance=recipe)

          # Onde:
            # Iremos mostrar um formulário com dados (request.POST) ou vazio (None)
            # Instance = recipe: É um formulário atrelado ao objeto recipe, então os dados que forem salvos nesse formulário estarão atualizando 
              esse objeto.
              Esse atributo é responsável por já carregar os campos do formulário com as informações contidas dentro do objeto receita, que 
              obtivemos com a queryset. Sem ele, quando clicássemos na receita, seria carregado um formulário vazio.
      # OBS. Como estamos utilizando o filter dentro da view para achar um elemento específico dentro da tabela, precisaremos utilizar ainda
        o método .first() para evitar problemas.


### Corrigindo o CSS do formulário e grid e dando toques finais no layout
  # É interessante que alguns campos não fiquem em uma coluna, mas ocupem o espaço inteiro da tela, como, por exemplo, cover e preparation_steps.
  # Criaremos uma class css chamada span-2, para sinalizar que a div que tiver ela como classe, deverá exibir algo em duas colunas e não em uma:

      .span-2 {
            grid-column: span 2;
        }

  # Iremos modificar os campos preparation__time_unit, servings_unit e cover. Os dois primeiros serão modificados para que o usuário possa 
    escolher valores padronizados, e o cover, será modificado para que, ao invés do link, seja mostrada a imagem em si, na hora de editar a 
    receita. Dentro da meta do form:
      # Modificando:
        
        widgets = {
          'cover': forms.FileInput(
            attrs={
              'class': 'span-2'                   
            }
          ),

          # Estamos dando à chave class do attr de 'cover' o valor 'span-2'. Isso até agora não faz nada, pois ainda não utilizamos essa classe no 
            formulário em si, mas assim, poderemos acessar esse valor de dentro do template.
            Faremos isso para preparation_steps também, pois também queremos mostrá-lo em uma coluna só. Lembre-se, nesse caso é TextArea.

          'servings_time_unit': forms.Select(
            choices=(
              ('Porções', 'Porções'),
              ('Pedaços', 'Pedaços'),
              ('Pessoas', 'Pessoas'),
            )
          ),
          preparation_time_unit': forms.Select(
            choices=(
              ('Minutos', 'Minutos'),
              ('Horas', 'Horas'),
            )
          )
        }
    # Em form.html, faça, dentro do for:
      {% if field.name == 'cover' %}
        <div class='span-2>
          <img src="{{ field.value.url }}" alt="Capa para '{{ recipe.title }}'">
        </div>
      
      # Isto é, se o campo for 'cover', ao invés do link, mostre o valor obtido ao ir até o link (a imagem).
      # Para que possamos utilizar os valores que demos aos attrs do widget dos campos dentro do formulário, modificaremos a div responsável
        por mostrá-los (div cuja classe é 'form-group'), ajustando sua classe (adicionando a o estilo da classe span-2):

          <div class="form-group {{ field.field.widget.attrs.class }}">   

          # Para campos cujo attr 'class' dentro de widgets que recebeu o valor 'span-2', a configuração acima faz com que a classe posta na
            div quando o for chegar nesse campo, ao invés de form-group, seja form-group span-2.
          # Porque? Estamos pegando o objeto da vez no for (que é um campo), acessando o atributo field desse campo, dentro dele, acessando 
            os widgets, dentro dos widgets, acessando os attr e dentro dos attr acessando o valor da chave 'class' que, para os bons campos,
            será span-2.
      # Até esse ponto, o objetivo foi cumprido no macro. O preparation_steps ocupava uma coluna só, mas tava curto, e os campos de seleção
      (forms.Select) estavam feios. O conserto foi a criação das classes:  .form-content input e form-content textarea, e juntá-las com o 
      conteúdo da classe form-content imput, ficando da seguinte forma:

          .form-content textarea,
          .form-content select,
          .form-content input {
            width: 100%;
            padding e etc.
          }   
      
      # Para que a imagem ficasse de tamanho normal na tela (do tamanho da div), pusemos uma classe global de css:

        img {
            max-width: 100%;
        }
      
      # Modificaremos de forma global os links

          a {
            color: var(--color-primary);
            text-decoration: none;
          }
    
    # Para fins estilísticos, modificaremos a mensagem no topo da tela que fala sobre logout: Você foi logado como davia. Por favor, clique aqui para efetuar logout.
      Faremos dois links, agora: Um para logout e um para retornar ao dashboard e ver as receitas:

        Veja suas receitas ou efetue logout.

      # Veremos que essa mensagem mudará ao longo do desenvolvimento do CRUD.

### Salvando a edição das receitas
  # Agora iremos fazer a validação do formulário. Eis um problema: Uma receita possui vários atributos e a criação da receita possui mais
    atributos que sua edição (não permitiríamos, por exemplo, que o usuário determinasse se ele vai ou não publicar a própria receita).
    Isso significa que, quando o usuário edita uma receita e envia os dados do formulário, estamos substituindo os dados antigos dessa receita
    pelos novos dados fornecidos pelo usuário, no entanto, o usuário não enviou todos os dados.
    Nesse sentido, o usuário enviará os dados, mas faremos com que estes não adentrem diretamente no banco de dados, pois uma parte das infor
    mações será fornecida pelo usuário, e a outra metade por nós. Para isso:

      from django.urls import reverse
      if form.is_valid():
        receita = form.save(commit=False)    

        receita.author = request.POST.user
        receita.preparation_steps_is_html = False     # Nós preenchemos inicialmente os campos que faltaram
        receita.is_published = False

        receita.save()              # Salvamos os dados na base de dados.

        return redirect(reverse('authors-dashboard-recipe-edit', args=(id,)))

  # O que deve acontecer é: Assim que clicarmos no nome de uma receita para editá-la, a dashboard_recipe_edit é carregada e a variável form
    recebe NONE, fazendo o formulário se tornar inválido. A view então renderiza o mesmo template novamente, mas agora tendo recebido os dados
    e passando para o form, que agora se dará como válido e irá salvar os dados sem problemas.

    Gambiarras: 
      # Usar um if no template form.html para verificar se quem quem incluiu o form.html foi o template chamado por 
    dashboard_recipe_edit ou por outro template. Se foi por dashboard_recipe_edit, então precisaremos de um id, do contrário, é desnecessário.
      # Usamos o reverse dentro do redirect porque eu não soube como passar o id dentro do redirect sozinho.
        Nesse caso, poderíamos ter retornado um render mesmo, que funcionaria.

  # Consertando a edição da imagem:
    # Quando estamos tratando de arquivos dentro de formulários, precisamos passar para a tag html do formulário o seguinte argumento, para
    informar o navegador:

        enctype="multipart/form-data"

      # Isso informa para o servidor e o navegador que o formulário vai trafegar arquivos. SEMPRE QUE O FORMULÁRIO TIVER ARQUIVOS, FAÇA ISSO.
      # Agora, informamos ao servidor que ele vai receber arquivos naquele formulário. Na view, faça:

        Ao invés de: form = AuthorRecipeForm(
        data=request.POST or None,
        instance=receita
    )
    Faça: 
      form = AuthorRecipeForm(
        data=request.POST or None,
        files=request.FILES or None,
        instance=receita
    )

### Criando a view para criação de novas receitas pelo usuário
  # Esta nova view, a dashboard_recipe_create será basicamente igual à dashboard_recipe_edit, tirando alguns detalhes que não farão sentido.
  # Uma diferença crucial acontece na hora de dar o falso commit:
    Ao invés de: receita = form.save(commit=False)
    Faremos: receita = form.save(commit=False)     
      # receita: Recipe, é como informamos em qual tabela salvaremos os dados.
  # Validando o formulário de criação de novas receitas com o clean.
    # Para dinamizar o processo, iremos usar um defaultdict: form collections import defaultdict
    # Utilizaremos o defaultdict para configurar os erros do formulário. Com o defaultdict, cada campo pode ter uma lista de erros.
    # Dentro da classe do formulário, faça:

        self._my_errors = defaultdict(list)   Qualquer chave desse dicionário vai ter uma lista vazia, inicialmente.
        # self._my_errors['bla'].append('legal') Se a chave 'bla' não existir, será criada e o append acontece, se existir, o append acontece.
    # O defautldict deve ser criado dentro de uma __init__:

        def __init__(self, *args, **kwargs):
          super().__init__(*args, **kwargs)
          self._my_errors = defaultdict(list)

    # Utilizaremos esse defaultdict dentro da função clean para validarmos o formulário inteiro. Crie a clean.
    # Para validar se os campos de seleção de números são números positivos, dentro da pasta utils, criaremos uma função que recebe uma string
    converte pra float e verifica se é positivo, retornando verdadeiro ou falso.

### CRUD para apagar receitas de forma segura + JavaScript
  # Até esse exato momento, já podemos Criar novas receitas (create), ver as receitas atuais (read) e atualizar as receitas (update). Do CRUD,
    já temos o CRU. só falta o D.
  # Na dashboard.html, na hora de mostrar as receitas, iremos criar um botão do lado das receitas do usuário. O estilo desse botão será
    o ícone de um X vermelho, indicando que o usuário pode deletar uma receita clicando naquele botão. 
      # Para isso, na dashboard.html, após mostrar o nome de cada receita, façamos:

          <form class="inline-form" action="">
            {% csrf_token %}
            <button class="plaintext-button "type="submit">❌</button>
          </form>
  
  # Agora criaremos a view para deletar receitas e conciliamos com o pedaço acima do template dashboard.html.
  # No entanto, uma vez que clicamos no X, a receita é deletada instantaneamente. O usuário pode clicar lá por engano, então precisamos criar
    uma confirmação para verificar se o usuário realmente deseja deletar a receita.
    Dentro do form acima, ampliaremos sua classe: <form class="inline-form form-delete" action="">, onde form-delete será uma classe criada e
    somente será usada para que possamos encontrar essa tag form com um script JavaScript que criaremos.
      # Em base_static, crie, junto com a pasta css, a pasta js, e dentro dela, crie um arquivo chamados scripts.js, onde criaremos uma função
      em js que fará aparecer uma janela de confirmação perguntando se temos certeza da deleção da receita.
      # Nesse caso, precisaremos usar {% load static %} dentro do footer.html e, antes do fechamento da tag footer: 
      <script src="{% static 'global/js/scripts.js' %}"></script>

        # O ideal é que fosse no base.html, mas não funcionou, a menos que pusesse a tag script duas vezes.








