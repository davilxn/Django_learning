# Seção 16 - Class Based Views (CBV)
    # As CBV não foram criadas para substituir as FBV, mas surgiram como ferramentas extras, que podem, de fato, serem usadas ao invés de FBV,
    mas não significa que são melhores.
    # Antes de darmos continuidade, é válido que façamos modificações para organizar os arquivos, agora que teremos dois tipos de views.
        # Criemos um pacote de nome 'views' e, dentro dele, 3 arquivos: __init__.py, FBV.py, CBV.py. T
        # Tudo o que estiver no arquivo views.py será copiado para dentro de FBV.py.
        # Dentro do __init__.py, faz-se: from .FBV import *. # flake8: noqa
        # Agora, dentro de cbv.py, criemos nossas Class Based Views.
        # Antes de continuar, haverá um commit.
    
    # A ideia inicial é criar uma CBV que execute exatamente a mesma função que a view dashboard_recipe_edit, de authors.views.fbv.
        # Dentro de cbv.py, criaremos a DashboardRecipeEdit, que herdará de uma CBV Base do django, vista na documentação: View.
        # Devemos ainda fazer todas as importações necessário (chato).
        # Para podermos utilizar essa classe e testá-la, iremos comentar a view homônima.
        # Devemos ainda consertar o urls.py.
            # Dentro de __init__.py, faça: from cbv.py import *. 
            # Lá no url.py, façamos:  views.DashboardRecipeView.as_view(), na hora de passar a função que seria a view (mas agora é classe).
        # De início, copiamos a view dentro da classe, e em diante, repararemos.
            from django.views import View.
            class DashboardRecipeEdit(View):

        # Dentro dessa classe, teremos inicialmente os métodos get() e post() e neles estruturaremos a view, com formato de classe.
        Essas são funções da classe herdada 'View'. Terão outras como delete(), put(), head(), patch()
    
    # Com a mesma ideia, substituiremos a dashboard_recipe_create. Com algumas modificações no recebimento do ID, bastará passar na url
    referente à dashboard_recipe_create essa mesma classe que acabamos de criar, pois ela também é capaz de fazer o que essa view fbv faz.
    As modificações no recebimento do ID se dão porque a view dashboard_recipe_create não precisa de um ID, e na classe, estamos obrigatoria
    mente recebendo um, então basta fazermos dele um parâmetro opcional, passando o valor padrão None.

    # Precisamos agora fazer com que só seja possível acessar a dashboard se o usuário estiver logado. No entanto, agora não estamos
    trabalhando diretamente com funções, mas sim com classes.
    Para isso, façamos: 
        from django.utils.decorators import method_decorator
        from django.contrib.auth.decorators import login_required

    Fazemos, antes da classe:

        @method_decorator(login_required(login_url='authors-login', redirect_field_name='next'), name='dispatch')

        Onde: dispatch serve para informar que o method_decorator deve ser aplicado para todas as funções da classe.
    
    ### Reutilizando a CBV como herança para deletar coisas.
        # Agora, ao invés de usar a mesma classe com view em outro lugar, criaremos uma nova classe, mas passando a classe que criamos como
          herança. 
        # Criemos a class based view DashboardRecipeDelete, que herdará de DashboardRecipeView e façamos o necessário para que ela cumpra a
        função da view que ela está substituindo.
        # Após isso, basta mudar no urls.py.
        # Decore a classe com o login_required

### Utilizando a ListView: Criando uma base para Home, Category e Search de recipes
    # Perceba que as views Home, Category e Search, do app recipes, são views de listas, isto é, retornam uma queryset para o template, onde 
    devemos mostrar todos os objetos..
    # Iremos substituir isso por ListViews. from django.views.generic import ListView
    # Em recipes/views.py, criemos a classe RecipeListView(ListView):
        # É decorativo, então se fará as modificações necessárias de acordo com os atributos da classe herdada.
        # Segura Ctrl e clica em ListView. Aparecerá a documentação da classe e lá tem os atributos importantes.
        # Feitas modificações, basta modificar as urls.
    # Esta classe será uma CBV de list view base, para que possamos passar como herança para as CBV de list view que criaremos posteriormente.
    # Dentro dessa CBV base, criaremos sobrescreveremos os seguintes métodos internos da classe herdada ListView: get_queryset() e 
      get_context_data():

      def get_queryset(self, *args, **kwargs):
        qs = super().get_queryset(*args, **kwargs)
        qs = qs.filter(is_published=True)
        return qs
    
      def get_context_data(self, *args, **kwargs):
        ctx = super().get_context_data(*args, **kwargs) 
        page_obj, pagination_range = make_pagination(self.request, ctx.get('recipes'), PER_PAGE) 
        ctx.update({'recipes': page_obj, 'pagination_range': pagination_range})       
        return ctx

        Onde: 
            - A primeira linha de get_context_data cria a variável que vai conter os dados do contexto, que são passados pela classe criada
            RecipeListView, que recebe do model ao qual a atrelamos. Essa variável contém um atributo que contém os dados do queryset que
            obtivemos na queryset (mágica), que possui, por padrão, como nome de sua chave "object_list", mas que nós nomeamos, através 
            da classe RecipeListView, pelo atributo 'context_object_name', como 'recipes' (que, novamente, é uma chave que tem como valor a nossas
            queryset, magicamente). Podemos acessar essa chave acessando: ctx.get('recipes'), onde get é uma função built-in de dicts.
            Anteriormente, cometi o erro de pôr context_object_name='recipes', e na hora de acessar ctx.get('recipes'), estava acessando um
            atributo do contexto da RecipeListViewBase, que tinha sido paginado e tinha 9 objetos, e não 900. Cuidado com nomenclaturas.
            Tentar acessar a queryset utilizando o retorno do método get_queryset não é uma boa ideia, embora funcione às vezes.

            - Na segunda linha, dos dados do contexto, pega o valor da chave nomeada como 'recipes' (queryset), o resto é a paginação.
            - Na terceira linha, criamos o contexto. Lá na FBV de Home tem essa mesma linha. Esse será o contexto da view.

    # Agora, tendo a base, podemos criar a classe RecipeListViewHome(RecipeListViewBase), modificando só o nome do template carregado.
    Podemos ainda, fazer o mesmo para as views category e search, mas para essa haverá necessidade de modificar get_queryset() e get_context_data()

### Movendo a FBV de detalhes da receita para a CBV DetailView
    # Criaremos a CBV RecipeDetail(DetailView). from django.views.generic import ListView
    # Essa view também terá seu método get_context_data sobrescrito.



    

