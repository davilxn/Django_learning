Seção 11 - Django Pagination - Paginação de QuerySet com django Pagination

Para que tenhamos receitas o suficiente para fazer uma paginação, faremos um esquema de duplicação de receitas.
No django shell, faça:

from recipes.models import Recipe
r = Recipe.objects.get(pk=1)
r.id = None; r.slug = f'duplicada - {1}'; r.save()
for i in range(1000): r.id = None; r.slug = f'duplicada - {i}'; r.save()
quit()

# Perceba que foram carregadas 1000 novas receitas em uma só página (a home). Isso é inviável, pois consome ao extremo os recursos do servidor e,
  dependendo da situação, os recursos do computador do cliente. É com essa problemática que se desenvolve a necessidade de fazer a paginação
  em um site.
# O django é bem auxiliador para ferramentas de paginação. Pesquise por 'django pagination documantation'.
# Para usar a paginação do django, em recipes/views.py, faz-se:
    # from django.core.paginator import paginator
    # Dentro da view home, faça: 
        paginator = Paginator(all_recipes, 9)   
            
        # O Paginator divide uma QuerySet em vários page object. Ao instanciar a classe Paginator, como feito acima, fornecemos um iterável 
          com objetos (o QuerySet) e o número de elementos que você gostaria de ter em cada página.
        # Em essência, o Paginator pega uma página gigante e divide em várias páginas, com base no número de elementos da QuerySet passada 
          e no número de elementos da QuerySet que você quer que apareça em cada página.
          aparece em uma pagina só, para várias páginas.
        # Exemplo completo de utilização e acesso de objetos com a Classe Paginator:

                from django.core.paginator import Paginator
                >>> objects = ['john', 'paul', 'george', 'ringo']
                >>> p = Paginator(objects, 2)

                >>> p.count         # Todas essa são funções da Classe Paginator
                4

                >>> p.num_pages
                2

                >>> p.get_page(1) # Pega o primeiro grupo da QuerySet que foi dividido, nesse caso 'john' e 'paul'.

                >>> type(p.page_range)
                <class 'range_iterator'>

                >>> p.page_range
                range(1, 3)

                >>> p.page_range
                range(1, 3)

                >>> page1 = p.page(1)
                >>> page1
                <Page 1 of 2>

                >>> page1.object_list
                ['john', 'paul']

                >>> page2 = p.page(2)
                >>> page2.object_list
                ['george', 'ringo']

                >>> page2.has_next()
                False

                >>> page2.has_previous()
                True

                >>> page2.has_other_pages()
                True

                >>> page2.next_page_number()
                Traceback (most recent call last):
                ...
                EmptyPage: That page contains no results

                >>> page2.previous_page_number()
                1
                >>> page2.start_index() # The 1-based index of the first item on this page
                3
                >>> page2.end_index() # The 1-based index of the last item on this page
                4

        # Antes de continuar, devemos modificar o template base.html para que possammos mostrar os índices das páginas. Desça até o fim da 
          página de uma pesquisa do google e veja os índices das próximas páginas de resultados da pesquisa: 1 2 3 4 5 6 7 8 9
        # Crie em recipes/partials o arquivo pagination.html e faça:

                    <div class='container-pagination'>         Claro que isso será mudado, posteriomente.
                        1 2 3 4 5
                    </div>

          # Em base.html dentro da tag main, faça: {% include recipes/partials/pagination.html %}
          # Em pagination.html, precisamos fazer um if, verificando se existem outras páginas, isto é, se a view que está chamando o template
            que está extendendo o base.html está dividindo a página em muitas páginas (utilizando o Paginator). Lembre-se que todos os templates
            extendem base.html então, indiretamente, todas as views 'renderizam' base.html. 
            
            Ex: Se chamarmos a página home.html, usamos a view  home, que usa o Paginator, que divide a página em muitas páginas, logo, deve 
            aparecer o índice de páginas. 
            Por outro lado, se clicamos em uma das receitas mostradas, estamos chamando a página recipe.html, carregada pela view recipe, que
            não divide a página em outras páginas (não usa o Paginator).

            Podemos fazer essa verificação através de um ATRIBUTO (não é método, não é função, e retorna TRUE ou FALSE) da classe Paginator: 
            O atributo .has_other_pages

            Além disso, a div não deve mostrar '1 2 3 4 5'. Deve mostrar um range de alguns índices de páginas, dentre todos os índices. Para
            isso, devemos construir uma lógica complexa, que será feita em uma função. Fora de qualquer app, crie uma pasta chamada 'utils' e,
            dentro dela, crie um arquivo chamado pagination.py. Dentro desse arquivo será feita a lógica para a paginação do site, e o retorno da 
            função criada dentro dela será utilizada de acordo com os atributos e métodos da Classe Paginator na view home.

            Essa função será a make_pagination_range e receberá 3 argumentos: page_range, qty_pages, current_page. 
              - page_range: Quantos índices de páginas existem ao todo. Quando fizemos a duplicação, foram criadas 1000 novas receitas, com 9 em
                cada página, o que nos dá um total de aproximadamente 112 páginas.
              - qty_pages: Quantos índices de páginas devemos mostrar. No caso do '1 2 3 4 5', o argumento desse parâmetro seria 5.
              - current_page: Página atual.

          # Precisamos ainda acessar a URL para verificar a chave 'page' e o seu valor. Para isso, como sabemos, pode-se usar o request.GET:

            current_page = request.GET.get('page', 1)   # Quero o valor da chave 'page', Se não tiver nada, retorne 1.

          # Com essa mudança, vem:

                page_obj = paginator.get(current_page)  
            
          # Agora a variável page_object refere-se a nossa página atual. Dessa forma, estamos mostrando as páginase, portanto, as receitas
            de acordo com o valor da chave 'page' da URL. Veja:

                    def home(request):
                        all_recipes = Recipe.objects.filter(is_published=True).order_by('-id')      
                        current_page = request.GET.get('page', 1)
                        paginator = Paginator(all_recipes, 9)
                        page_obj = paginator.get_page(current_page)

                        return render(request, 'recipes/pages/home.html', context={
                            'recipes': page_obj,
                            'tam': len(all_recipes),
                    })
                
                # current_page recebe o valor da chave 'page' e passa para a função get_page, que encontra a página referente ao número passado,
                  no caso, o valor de 'page'. Essa função devolve a página em questão, com a QuerySet em questão e nós passamos para o dicionário
                  context.
                # Você pode estar se perguntando: Por que 'page'? Na verdade 'page' foi só um nome que eu selecionei arbitrariamente e mandei a 
                  a função request.Get.get() procurar como uma chave dentro da URL. Se eu mudar, na função, de 'page' para 'ola' e digitar a URL
                  http://127.0.0.1:8000/?page=40, permaneceremos na mesma página. Mas se eu digitar http://127.0.0.1:8000/?ola=40, vamos para a 
                  página de índice 40.
                # Agora, precisamos configurar o template para que, toda vez que eu clicar em um índice, a chave 'page' na URL assuma 
                  o valor do índice em questão. Dúvidas sobre o request.GET.get() -> Anotações6.txt. Façamos o seguinte, em paginatio.html:

                    {% if recipes.has_other_pages %}
                      <div class="container-pagination">
                          <div class="pagination-content">
                              {% for ind in pagination_range.pagination_ff %}
                                  <a class="page-link page-item" href="?page={{ ind }}"> {{ ind }} </a>
                              {% endfor %}
                          </div>
                      </div>
                    {% endif %}

                # Explicando: A utilização do atributo has_other_pages foi explicada acima.
                  Ao clicar em um dos índices, estamos clicando em um link, que será o link atual unido a /?page=indicequeclicou. Até agora só 
                  usamos o Paginator na view home, então a view home será chamada com esse índice dado como valor para a chave 'page'.
                  Receberemos o valor dessa chave na view através do request.GET.get().
                  Instanciaremos a classe Paginator, dividindo a QuerySet all_recipes em 112 páginas home.html, com 9 em cada. Através da 
                  capturado valor da chave 'page', encontraremos a página atual do usuário (qual das 112), que também é uma divisão da 
                  QuerySet all_recipes, que será passado no contexto da view home.
                  Chamamos a função make_pagination_range(), que retorna um dicionário, que passaremos no contexto da view home.
                  Cada vez que clicamos num índice, vamos para outra página, chamamos novamente a view home e novamente a função
                  make_pagination_range, que sempre modifica seus valores de retorno de acordo com a entrada que passamos.

        # No entanto, qualquer uma de nossas páginas que apresentar uma QuerySet com vários elementos, precisará de paginação. Isso inclui o 
          template categories. Ao invés de fazer o mesmo processo acima para todos as views, criaremos uma função, dentro de pagination.py que
          faça isso, a função make_pagination(). Nesse ponto, iremos, basicamente, copiar o conteúdo da view recipe e colar nessa nova função.
          Em dúvida, veja o commit.


                