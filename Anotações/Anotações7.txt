Seção 11 - Django Pagination - Paginação de QuerySet com django Pagination

Para que tenhamos receitas o suficiente para fazer uma paginação, faremos um esquema de duplicação de receitas.
No django shell, faça:

from recipes.models import Recipe
r = Recipe.objects.get(pk=1)
r.id = None; r.slug = f'duplicada - {1}'; r.save()
for i in range(1000): r.id = None; r.slug = f'duplicada - {i}'; r.save()
quit()

# Perceba que foram carregadas 1000 novas receitas em uma só página (a home). Isso é inviável, pois consome ao extremo os recursos do servidor e,
  dependendo da situação, os recursos do computador do cliente. É com essa problemática que se desenvolve a necessidade de fazer a paginação
  em um site.
# O django é bem auxiliador para ferramentas de paginação. Pesquise por 'django pagination documantation'.
# Para usar a paginação do django, em recipes/views.py, faz-se:
    # from django.core.paginator import paginator
    # Dentro da view home, faça: 
        paginator = Paginator(all_recipes, 9)   
            
        # O Paginator divide uma QuerySet em vários page object. Ao instanciar a classe Paginator, como feito acima, fornecemos um iterável 
          com objetos (o QuerySet) e o número de elementos que você gostaria de ter em cada página.
        # Em essência, o Paginator pega uma página gigante e divide em várias páginas, com base no número de elementos da QuerySet passada 
          e no número de elementos da QuerySet que você quer que apareça em cada página.
          aparece em uma pagina só, para várias páginas.
        # Exemplo completo de utilização e acesso de objetos com a Classe Paginator:

                from django.core.paginator import Paginator
                >>> objects = ['john', 'paul', 'george', 'ringo']
                >>> p = Paginator(objects, 2)

                >>> p.count         # Todas essa são funções da Classe Paginator
                4

                >>> p.num_pages
                2

                >>> p.get_page(1) # Pega o primeiro grupo da QuerySet que foi dividido, nesse caso 'john' e 'paul'.

                >>> type(p.page_range)
                <class 'range_iterator'>

                >>> p.page_range
                range(1, 3)

                >>> p.page_range
                range(1, 3)

                >>> page1 = p.page(1)
                >>> page1
                <Page 1 of 2>

                >>> page1.object_list
                ['john', 'paul']

                >>> page2 = p.page(2)
                >>> page2.object_list
                ['george', 'ringo']

                >>> page2.has_next()
                False

                >>> page2.has_previous()
                True

                >>> page2.has_other_pages()
                True

                >>> page2.next_page_number()
                Traceback (most recent call last):
                ...
                EmptyPage: That page contains no results

                >>> page2.previous_page_number()
                1
                >>> page2.start_index() # The 1-based index of the first item on this page
                3
                >>> page2.end_index() # The 1-based index of the last item on this page
                4

        # Antes de continuar, devemos modificar o template base.html para que possammos mostrar os índices das páginas. Desça até o fim da 
          página de uma pesquisa do google e veja os índices das próximas páginas de resultados da pesquisa: 1 2 3 4 5 6 7 8 9
        # Crie em recipes/partials o arquivo pagination.html e faça:

                    <div class='container-pagination'>         Claro que isso será mudado, posteriomente.
                        1 2 3 4 5
                    </div>

          # Em base.html dentro da tag main, faça: {% include recipes/partials/pagination.html %}
          # Em pagination.html, precisamos fazer um if, verificando se existem outras páginas, isto é, se a view que está chamando o template
            que está extendendo o base.html está dividindo a página em muitas páginas (utilizando o Paginator). Lembre-se que todos os templates
            extendem base.html então, indiretamente, todas as views 'renderizam' base.html. 
            
            Ex: Se chamarmos a página home.html, usamos a view  home, que usa o Paginator, que divide a página em muitas páginas, logo, deve 
            aparecer o índice de páginas. 
            Por outro lado, se clicamos em uma das receitas mostradas, estamos chamando a página recipe.html, carregada pela view recipe, que
            não divide a página em outras páginas (não usa o Paginator).

            Podemos fazer essa verificação através de um ATRIBUTO (não é método, não é função, e retorna TRUE ou FALSE) da classe Paginator: 
            O atributo .has_other_pages

            Além disso, a div não deve mostrar '1 2 3 4 5'. Deve mostrar um range de alguns índices de páginas, dentre todos os índices. Para
            isso, devemos construir uma lógica complexa, que será feita em uma função. Fora de qualquer app, crie uma pasta chamada 'utils' e,
            dentro dela, crie um arquivo chamado pagination.py. Dentro desse arquivo será feita a lógica para a paginação do site, e o retorno da 
            função criada dentro dela será utilizada de acordo com os atributos e métodos da Classe Paginator na view home.

            Essa função será a make_pagination_range e receberá 3 argumentos: page_range, qty_pages, current_page. 
              - page_range: Quantos índices de páginas existem ao todo. Quando fizemos a duplicação, foram criadas 1000 novas receitas, com 9 em
                cada página, o que nos dá um total de aproximadamente 112 páginas.
              - qty_pages: Quantos índices de páginas devemos mostrar. No caso do '1 2 3 4 5', o argumento desse parâmetro seria 5.
              - current_page: Página atual.

          # Precisamos ainda acessar a URL para verificar a chave 'page' e o seu valor. Para isso, como sabemos, pode-se usar o request.GET:

            current_page = request.GET.get('page', 1)   # Quero o valor da chave 'page', Se não tiver nada, retorne 1.

          # Com essa mudança, vem:

                page_obj = paginator.get(current_page)  
            
          # Agora a variável page_object refere-se a nossa página atual. Dessa forma, estamos mostrando as páginase, portanto, as receitas
            de acordo com o valor da chave 'page' da URL. Veja:

                    def home(request):
                        all_recipes = Recipe.objects.filter(is_published=True).order_by('-id')      
                        current_page = request.GET.get('page', 1)
                        paginator = Paginator(all_recipes, 9)
                        page_obj = paginator.get_page(current_page)

                        return render(request, 'recipes/pages/home.html', context={
                            'recipes': page_obj,
                            'tam': len(all_recipes),
                    })
                
                # current_page recebe o valor da chave 'page' e passa para a função get_page, que encontra a página referente ao número passado,
                  no caso, o valor de 'page'. Essa função devolve a página em questão, com a QuerySet em questão e nós passamos para o dicionário
                  context.
                # Você pode estar se perguntando: Por que 'page'? Na verdade 'page' foi só um nome que eu selecionei arbitrariamente e mandei a 
                  a função request.Get.get() procurar como uma chave dentro da URL. Se eu mudar, na função, de 'page' para 'ola' e digitar a URL
                  http://127.0.0.1:8000/?page=40, permaneceremos na mesma página. Mas se eu digitar http://127.0.0.1:8000/?ola=40, vamos para a 
                  página de índice 40.
                # Agora, precisamos configurar o template para que, toda vez que eu clicar em um índice, a chave 'page' na URL assuma 
                  o valor do índice em questão. Dúvidas sobre o request.GET.get() -> Anotações6.txt. Façamos o seguinte, em paginatio.html:

                    {% if recipes.has_other_pages %}
                      <div class="container-pagination">
                          <div class="pagination-content">
                              {% for ind in pagination_range.pagination_ff %}
                                  <a class="page-link page-item" href="?page={{ ind }}"> {{ ind }} </a>
                              {% endfor %}
                          </div>
                      </div>
                    {% endif %}

                # Explicando: A utilização do atributo has_other_pages foi explicada acima.
                  Ao clicar em um dos índices, estamos clicando em um link, que será o link atual unido a /?page=indicequeclicou. Até agora só 
                  usamos o Paginator na view home, então a view home será chamada com esse índice dado como valor para a chave 'page'.
                  Receberemos o valor dessa chave na view através do request.GET.get().
                  Instanciaremos a classe Paginator, dividindo a QuerySet all_recipes em 112 páginas home.html, com 9 em cada. Através da 
                  capturado valor da chave 'page', encontraremos a página atual do usuário (qual das 112), que também é uma divisão da 
                  QuerySet all_recipes, que será passado no contexto da view home.
                  Chamamos a função make_pagination_range(), que retorna um dicionário, que passaremos no contexto da view home.
                  Cada vez que clicamos num índice, vamos para outra página, chamamos novamente a view home e novamente a função
                  make_pagination_range, que sempre modifica seus valores de retorno de acordo com a entrada que passamos.

        # No entanto, qualquer uma de nossas páginas que apresentar uma QuerySet com vários elementos, precisará de paginação. Isso inclui o 
          template categories. Ao invés de fazer o mesmo processo acima para todos as views, criaremos uma função, dentro de pagination.py que
          faça isso, a função make_pagination(). Nesse ponto, iremos, basicamente, copiar o conteúdo da view recipe e colar nessa nova função.
          Em dúvida, veja o commit 'metade da paginação', que ocorreu antes dessa mudança.

        # Ao utilizar a função na view search, aparentemente, o funcionamento ocorre como esperado. No entanto, ao procurar por um termo genérico
        na área de pesquisa como 'a', por exemplo (muitas receitas o contém em seu título), e então clicarmos em um dos índices de paginação, ocorre
        um erro. Isso porque, ao clicar no índice, interagimos direto com pagination.html que em seu interior, desconsidera a chave de query de url
        (url query) chamada 'q', relevante no campo de busca. Para isso, deveremos passar ela como contexto na view, que será então carregada junto
        com a página search, que extende o base.html, que inclui o pagination.html que irá usar essa informação de uma maneira esperta.

### DOTENV
  # É importante perceber que, aquele 9 se repete muitas vezes e que, provavelmente, se fossemos desenvolver paginação em outras apps
    desse projeto, faríamos exatamente nesse mesmo modelo, contendo 9 objetos por página. E essa é uma parte bem importante da páginação
    que, se precisar ser mudada, teríamos que modificar esse 9 em cada função em que ele é usado.

    Uma boa prática seria criar uma CONSTANTE antes das views: PER_PAGE = 9.
    O Python não possui o conceito de constantes, mas se você criar uma variável com todas as letras maiúsculas, fica subentendido que
    o valor daquela variável não deve ser modificado e, portanto, ela é uma constante. Ao invés de usar 9, nas funções, usa-se PER_PAGE.

    No entanto, em algum momento, é possível que precisemos mover algumas constantes (essencialmente constantes da settings.py) para o
    ambiente. Isso porque, em certas variáveis do settings.py existem informações confidenciais que não podem ser públicas e não podem, por
    exemplo, irem parar no github. A solução para isso, é criar variáveis de ambiente, isto é, variáveis que estão atreladas a determinado
    ambiente, determinado computador, determinado usuário.

    Para usar essas variáveis no django, utilizaremos dotenv: pip install python-dotenv.
    No django, podemos carregar isso em 3 lugares diferentes. 
      # No arquivo manage.py e no asgi.py façamos: from dotenv import load_dotenv
        # Dentro da função main de manage.py, após o os.environment, faça: load_dotenv()
        # Antes da variável application de asgi.py, faça: load_dotenv()
      # Fora de qualquer pasta, na raiz do projeto, na mesma pasta que requirements.txt, criemos um arquivo chamado: .env. Nele, poremos senhas
        variáveis de ambiente, secret keys e etc. Esse arquivo não estará no github, então se você pegar a aplicação de outra pessoa, não terá
        acesso direto a ele (pois ele está no gitignore), mas terá acesso direto a outra versão dele, o .env-example
      # Além disso, criaremos uma outra versão desse arquivo, que será uma cópia dele com o nome: .env-example.
      # Regra de todos os desenvolvedores: Quando você trabalhar em uma aplicação alheia e ver um arquivo nomeado como .env-example, deve copiar
        todo o conteúdo desse arquivo, criar um arquivo .env, colar o conteúdo copiado nesse arquivo e excluir o .env-example.
          # É mais fácil copiar o .env-example que recebeu e renomeá-lo.
      
      # Agora, preencheremos o .env: PER_PAGE=9
      # Lá na views.py onde foi utilizada a PER_PAGE, faça:
        
        import os
        PER_PAGE = os.environ.get('PER_PAGE', 6)  # Isto é, busque uma variável de ambiente com esse nome e pegue seu valor ou retorne 6.
    
    # Criando mais variáveis de ambiente
      # SECRET_KEY
        # Para obter uma secret_key, façamos, no terminal: 
          python -c "import string as s;from random import SystemRandom as sr;print(''.join(sr().choices(s.ascii_letters + s.punctuation, k=64)))"

          Isso pode gerar valores para senhas e etc. Se houver aspas no meio do valor, substitua por outro caractere qualquer.

        # Dentro do .env, façamos:

          SECRET_KEY = ;X@m{%"v%D{mjo.([f^g(/d(b)GyqjkE>z(dpj'TNhavOucG$:K-@nuK.Z\VVs-,

        # E no settings.py: SECRET_KEY = os.environ.get('SECRET_KEY', 'INSECURE')
      
      # DEBUG
        # Em .env: DEBUG = 0
        # No settings.py: True if os.environ.get('DEBUG') == '1' else False






                